<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×•×™×–×•××œ×™×–×¦×™×” ××™× ×˜×¨××§×˜×™×‘×™×ª - ×¡×•×’×™ ×œ××™×“×” ××›×•× ×”</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            direction: rtl;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #e0e0e0;
            flex-wrap: wrap;
        }

        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background: #f5f5f5;
            border: none;
            font-size: 1.1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            min-width: 150px;
        }

        .tab:hover {
            background: #e8e8e8;
        }

        .tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .content {
            padding: 40px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section-title {
            font-size: 2em;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .description {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.8;
        }

        .visualization-container {
            background: #f9f9f9;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        .slider-label {
            font-weight: 600;
            color: #333;
            min-width: 150px;
        }

        .slider {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .info-box {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .info-box h3 {
            margin-bottom: 10px;
        }

        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .example-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s;
        }

        .example-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transform: translateY(-5px);
        }

        .example-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .canvas-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ ×•×™×–×•××œ×™×–×¦×™×” ××™× ×˜×¨××§×˜×™×‘×™×ª - ×¡×•×’×™ ×œ××™×“×” ××›×•× ×”</h1>
            <p>×’×œ×” ×•×—×§×•×¨ ××ª ×¡×•×’×™ ×”×œ××™×“×” ×”××›×•× ×” ×”×©×•× ×™× ×‘×××¦×¢×•×ª ×“×•×’×××•×ª ××™× ×˜×¨××§×˜×™×‘×™×•×ª</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('supervised')">×œ××™×“×” ××•× ×—×™×ª</button>
            <button class="tab" onclick="switchTab('unsupervised')">×œ××™×“×” ×œ× ××•× ×—×™×ª</button>
            <button class="tab" onclick="switchTab('reinforcement')">×œ××™×“×” ×—×™×–×•×§</button>
            <button class="tab" onclick="switchTab('deep')">×œ××™×“×” ×¢××•×§×”</button>
        </div>

        <div class="content">
            <!-- ×œ××™×“×” ××•× ×—×™×ª -->
            <div id="supervised" class="tab-content active">
                <h2 class="section-title">×œ××™×“×” ××•× ×—×™×ª (Supervised Learning)</h2>
                <p class="description">
                    ×œ××™×“×” ××•× ×—×™×ª ×”×™× ×¡×•×’ ×©×œ ×œ××™×“×” ××›×•× ×” ×©×‘×” ×”××•×“×œ ×œ×•××“ ××ª×•×š ×“×•×’×××•×ª ××¡×•×× ×•×ª.
                    ×”××•×“×œ ××§×‘×œ ×§×œ×˜ ×•×ª×•×¦××” ×¨×¦×•×™×”, ×•×œ×•××“ ×œ××¦×•× ××ª ×”×§×©×¨ ×‘×™× ×™×”×.
                </p>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">×¡×™×•×•×’ (Classification) - ×”×¤×¨×“×ª × ×§×•×“×•×ª</h3>
                    <div class="canvas-container">
                        <canvas id="classificationCanvas" width="600" height="400"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #ff6384;"></div>
                                <span>××—×œ×§×” 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #36a2eb;"></div>
                                <span>××—×œ×§×” 2</span>
                            </div>
                        </div>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="trainClassifier()">××™××•×Ÿ ×”××•×“×œ</button>
                        <button class="btn" onclick="clearClassificationCanvas()">× ×§×”</button>
                        <button class="btn" onclick="addRandomPoints()">×”×•×¡×£ × ×§×•×“×•×ª ××§×¨××™×•×ª</button>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>×œ×—×¥ ×¢×œ ×”×§× ×‘×¡ ×›×“×™ ×œ×”×•×¡×™×£ × ×§×•×“×•×ª. × ×§×•×“×•×ª ×‘×¦×“ ×©×××œ ×©×™×™×›×•×ª ×œ××—×œ×§×” 1 (××“×•×), × ×§×•×“×•×ª ×‘×¦×“ ×™××™×Ÿ ×œ××—×œ×§×” 2 (×›×—×•×œ). ×œ×—×¥ ×¢×œ "××™××•×Ÿ ×”××•×“×œ" ×›×“×™ ×œ×¨××•×ª ××ª ×§×• ×”×”×¤×¨×“×” ×©×”××•×“×œ ×œ××“.</p>
                    </div>
                </div>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">×¨×’×¨×¡×™×” (Regression) - ×—×™×–×•×™ ×¢×¨×›×™× ×¨×¦×™×¤×™×</h3>
                    <div class="chart-wrapper">
                        <canvas id="regressionChart"></canvas>
                    </div>
                    <div class="controls">
                        <div class="slider-container">
                            <span class="slider-label">××™×“×ª ×¤×•×œ×™× ×•×:</span>
                            <input type="range" min="1" max="5" value="1" class="slider" id="polynomialDegree" oninput="updateRegression()">
                            <span id="degreeValue">1</span>
                        </div>
                        <button class="btn" onclick="addNoise()">×”×•×¡×£ ×¨×¢×©</button>
                        <button class="btn" onclick="resetRegression()">××™×¤×•×¡</button>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>×¨×’×¨×¡×™×” ×× ×¡×” ×œ××¦×•× ××ª ×”×§×• ××• ×”×¢×§×•××” ×”×˜×•×‘×” ×‘×™×•×ª×¨ ×©×¢×•×‘×¨×ª ×“×¨×š ×”× ×§×•×“×•×ª. × ×¡×” ×œ×©× ×•×ª ××ª ××™×“×ª ×”×¤×•×œ×™× ×•× ×›×“×™ ×œ×¨××•×ª ××™×š ×”××•×“×œ ××ª××™× ××ª ×¢×¦××• ×œ× ×ª×•× ×™×.</p>
                    </div>
                </div>

                <div class="examples">
                    <div class="example-card">
                        <h4>ğŸ“§ ×–×™×”×•×™ ×¡×¤××</h4>
                        <p>×¡×™×•×•×’ ××™××™×™×œ×™× ×œ×¡×¤×× ××• ×œ× ×¡×¤×× ×¢×œ ×‘×¡×™×¡ ×ª×•×›×Ÿ ×”××™××™×™×œ</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ¥ ××‘×—×•×Ÿ ×¨×¤×•××™</h4>
                        <p>×¡×™×•×•×’ ×ª××•× ×•×ª ×¨× ×˜×’×Ÿ ×œ× ×•×¨××œ×™×•×ª ××• ×—×¨×™×’×•×ª</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ’° ×—×™×–×•×™ ××—×™×¨×™×</h4>
                        <p>×—×™×–×•×™ ××—×™×¨×™ ×‘×ª×™× ×¢×œ ×‘×¡×™×¡ ×’×•×“×œ, ××™×§×•× ×•×××¤×™×™× ×™× × ×•×¡×¤×™×</p>
                    </div>
                </div>
            </div>

            <!-- ×œ××™×“×” ×œ× ××•× ×—×™×ª -->
            <div id="unsupervised" class="tab-content">
                <h2 class="section-title">×œ××™×“×” ×œ× ××•× ×—×™×ª (Unsupervised Learning)</h2>
                <p class="description">
                    ×œ××™×“×” ×œ× ××•× ×—×™×ª ×”×™× ×¡×•×’ ×©×œ ×œ××™×“×” ××›×•× ×” ×©×‘×” ×”××•×“×œ ××—×¤×© ×“×¤×•×¡×™× ×‘× ×ª×•× ×™× ×œ×œ× ×ª×•×•×™×•×ª.
                    ×”××•×“×œ ×¦×¨×™×š ×œ×’×œ×•×ª ×‘×¢×¦××• ××ª ×”××‘× ×” ×•×”×“×¤×•×¡×™× ×‘× ×ª×•× ×™×.
                </p>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">×§×™×‘×•×¥ (Clustering) - K-Means</h3>
                    <div class="canvas-container">
                        <canvas id="clusteringCanvas" width="600" height="400"></canvas>
                        <div class="legend" id="clusteringLegend"></div>
                    </div>
                    <div class="controls">
                        <div class="slider-container">
                            <span class="slider-label">××¡×¤×¨ ××©×›×•×œ×•×ª (K):</span>
                            <input type="range" min="2" max="6" value="3" class="slider" id="kValue" oninput="updateKMeans()">
                            <span id="kValueDisplay">3</span>
                        </div>
                        <button class="btn" onclick="runKMeans()">×”×¨×¥ K-Means</button>
                        <button class="btn" onclick="clearClusteringCanvas()">× ×§×”</button>
                        <button class="btn" onclick="generateClusters()">×¦×•×¨ × ×§×•×“×•×ª ××§×¨××™×•×ª</button>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>K-Means ××—×¤×© K ××¨×›×–×™ ××©×›×•×œ×•×ª ×‘× ×ª×•× ×™× ×•××—×œ×§ ××ª ×”× ×§×•×“×•×ª ×œ×¤×™ ×”×§×¨×‘×” ×œ××¨×›×–×™×. ×œ×—×¥ ×¢×œ "×”×¨×¥ K-Means" ×›×“×™ ×œ×¨××•×ª ××ª ×”×ª×”×œ×™×š.</p>
                    </div>
                </div>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">×”×¤×—×ª×ª ×××“×™× (Dimensionality Reduction) - PCA</h3>
                    <div class="chart-wrapper">
                        <canvas id="pcaChart"></canvas>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="generatePCA()">×¦×•×¨ × ×ª×•× ×™× 3D</button>
                        <button class="btn" onclick="applyPCA()">×”×—×œ PCA</button>
                        <button class="btn" onclick="resetPCA()">××™×¤×•×¡</button>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>PCA (Principal Component Analysis) ××¤×—×™×ª ××ª ××¡×¤×¨ ×”×××“×™× ×‘× ×ª×•× ×™× ×ª×•×š ×©××™×¨×” ×¢×œ ×”××™×“×¢ ×”×—×©×•×‘ ×‘×™×•×ª×¨. ×›××Ÿ ×× ×• ××¦×™×’×™× ×”×¤×—×ª×” ×-3D ×œ-2D.</p>
                    </div>
                </div>

                <div class="examples">
                    <div class="example-card">
                        <h4>ğŸ›’ × ×™×ª×•×— ×œ×§×•×—×•×ª</h4>
                        <p>×§×™×‘×•×¥ ×œ×§×•×—×•×ª ×œ×¤×™ ×”×ª× ×”×’×•×ª ×§× ×™×™×” ×“×•××”</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ” ×–×™×”×•×™ ×× ×•××œ×™×•×ª</h4>
                        <p>×–×™×”×•×™ ×¤×¢×™×œ×•×ª ×—×¨×™×’×” ×‘×¨×©×ª×•×ª ××—×©×‘×™×</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ“Š ×•×™×–×•××œ×™×–×¦×™×”</h4>
                        <p>×”×¦×’×ª × ×ª×•× ×™× ×¨×‘-×××“×™×™× ×‘××¨×—×‘ ×“×•-×××“×™</p>
                    </div>
                </div>
            </div>

            <!-- ×œ××™×“×ª ×—×™×–×•×§ -->
            <div id="reinforcement" class="tab-content">
                <h2 class="section-title">×œ××™×“×ª ×—×™×–×•×§ (Reinforcement Learning)</h2>
                <p class="description">
                    ×œ××™×“×ª ×—×™×–×•×§ ×”×™× ×¡×•×’ ×©×œ ×œ××™×“×” ××›×•× ×” ×©×‘×” ×¡×•×›×Ÿ ×œ×•××“ ×œ×¤×¢×•×œ ×‘×¡×‘×™×‘×” ×¢×œ ×™×“×™ ×§×‘×œ×ª ××©×•×‘ (×—×™×–×•×§ ×—×™×•×‘×™ ××• ×©×œ×™×œ×™).
                    ×”×¡×•×›×Ÿ ×œ×•××“ ×“×¨×š × ×™×¡×•×™ ×•×˜×¢×™×™×” ××”×™ ×”×¤×¢×•×œ×” ×”×˜×•×‘×” ×‘×™×•×ª×¨ ×‘×›×œ ××¦×‘.
                </p>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">××‘×•×š (Maze) - Q-Learning</h3>
                    <div class="canvas-container">
                        <canvas id="mazeCanvas" width="500" height="500"></canvas>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="trainAgent()">××™××•×Ÿ ×”×¡×•×›×Ÿ</button>
                        <button class="btn" onclick="testAgent()">×”×¨×¥ ×¡×•×›×Ÿ ×××•××Ÿ</button>
                        <button class="btn" onclick="resetMaze()">××™×¤×•×¡</button>
                    </div>
                    <div class="slider-container">
                        <span class="slider-label">××¡×¤×¨ ××™××•× ×™×:</span>
                        <input type="range" min="100" max="5000" value="1000" class="slider" id="trainingEpisodes" oninput="updateEpisodes()">
                        <span id="episodesValue">1000</span>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>×”×¡×•×›×Ÿ ×œ×•××“ ×œ× ×•×•×˜ ×‘××‘×•×š ×¢×œ ×™×“×™ ×§×‘×œ×ª ×¤×¨×¡ (reward) ×›×©×”×•× ××’×™×¢ ×œ×™×¢×“. ×œ×—×¥ ×¢×œ "××™××•×Ÿ ×”×¡×•×›×Ÿ" ×›×“×™ ×œ×¨××•×ª ××ª ×ª×”×œ×™×š ×”×œ××™×“×”.</p>
                    </div>
                </div>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">×’×¨×£ ×œ××™×“×” - Q-Values</h3>
                    <div class="chart-wrapper">
                        <canvas id="rlChart"></canvas>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>×”×’×¨×£ ××¦×™×’ ××ª ×”×©×™×¤×•×¨ ×‘×‘×™×¦×•×¢×™ ×”×¡×•×›×Ÿ ×œ××•×¨×š ×–××Ÿ ×”××™××•×Ÿ. ×›×›×œ ×©×”×¡×•×›×Ÿ ×œ×•××“ ×™×•×ª×¨, ×”×•× ××¦×œ×™×— ×œ×”×’×™×¢ ×œ×™×¢×“ ××”×¨ ×™×•×ª×¨.</p>
                    </div>
                </div>

                <div class="examples">
                    <div class="example-card">
                        <h4>ğŸ® ××©×—×§×™×</h4>
                        <p>××™××•×Ÿ ×¡×•×›× ×™× ×œ×©×—×§ ××©×—×§×™× ×›××• ×©×—××˜ ××• Go</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ¤– ×¨×•×‘×•×˜×™×§×”</h4>
                        <p>×œ×™××•×“ ×¨×•×‘×•×˜×™× ×œ×œ×›×ª ××• ×œ×‘×¦×¢ ××©×™××•×ª ××•×¨×›×‘×•×ª</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸš— × ×”×™×’×” ××•×˜×•× ×•××™×ª</h4>
                        <p>××™××•×Ÿ ×›×œ×™ ×¨×›×‘ ××•×˜×•× ×•××™×™× ×œ× ×”×•×’ ×‘×‘×˜×—×”</p>
                    </div>
                </div>
            </div>

            <!-- ×œ××™×“×” ×¢××•×§×” -->
            <div id="deep" class="tab-content">
                <h2 class="section-title">×œ××™×“×” ×¢××•×§×” (Deep Learning)</h2>
                <p class="description">
                    ×œ××™×“×” ×¢××•×§×” ×”×™× ×ª×ª-×ª×—×•× ×©×œ ×œ××™×“×” ××›×•× ×” ×”××©×ª××© ×‘×¨×©×ª×•×ª × ×•×™×¨×•× ×™× ×¢××•×§×•×ª (×¨×‘-×©×›×‘×ª×™×•×ª).
                    ×¨×©×ª×•×ª ××œ×” ×™×›×•×œ×•×ª ×œ×œ××•×“ ×™×™×¦×•×’×™× ××•×¨×›×‘×™× ×××•×“ ×©×œ ×”× ×ª×•× ×™×.
                </p>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">×¨×©×ª × ×•×™×¨×•× ×™× - ××¨×›×™×˜×§×˜×•×¨×”</h3>
                    <div class="canvas-container">
                        <canvas id="neuralNetworkCanvas" width="800" height="500"></canvas>
                    </div>
                    <div class="controls">
                        <div class="slider-container">
                            <span class="slider-label">××¡×¤×¨ ×©×›×‘×•×ª × ×¡×ª×¨×•×ª:</span>
                            <input type="range" min="1" max="5" value="2" class="slider" id="hiddenLayers" oninput="updateNeuralNetwork()">
                            <span id="layersValue">2</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">× ×•×™×¨×•× ×™× ×‘×©×›×‘×”:</span>
                            <input type="range" min="2" max="10" value="4" class="slider" id="neuronsPerLayer" oninput="updateNeuralNetwork()">
                            <span id="neuronsValue">4</span>
                        </div>
                        <button class="btn" onclick="animateForward()">×”×¨×¥ Forward Pass</button>
                        <button class="btn" onclick="resetNeuralNetwork()">××™×¤×•×¡</button>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>×¨×©×ª × ×•×™×¨×•× ×™× ××•×¨×›×‘×ª ××©×›×‘×•×ª ×©×œ × ×•×™×¨×•× ×™× ×”××—×•×‘×¨×™× ×–×” ×œ×–×”. ×›×œ × ×•×™×¨×•×Ÿ ××§×‘×œ ×§×œ×˜, ××—×©×‘ ×¤×•× ×§×¦×™×”, ×•×©×•×œ×— ××ª ×”×¤×œ×˜ ×œ× ×™×¨×•× ×™× ×‘×©×›×‘×” ×”×‘××”.</p>
                    </div>
                </div>

                <div class="visualization-container">
                    <h3 style="text-align: center; margin-bottom: 20px;">××™××•×Ÿ ×¨×©×ª - Loss Function</h3>
                    <div class="chart-wrapper">
                        <canvas id="trainingChart"></canvas>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="startTraining()">×”×ª×—×œ ××™××•×Ÿ</button>
                        <button class="btn" onclick="stopTraining()">×¢×¦×•×¨</button>
                        <button class="btn" onclick="resetTraining()">××™×¤×•×¡</button>
                    </div>
                    <div class="info-box">
                        <h3>××™×š ×–×” ×¢×•×‘×“?</h3>
                        <p>×‘××”×œ×š ×”××™××•×Ÿ, ×”×¨×©×ª ×× ×¡×” ×œ×”×§×˜×™×Ÿ ××ª ×”-Loss (×”×©×’×™××”) ×¢×œ ×™×“×™ ×¢×“×›×•×Ÿ ×”××©×§×•×œ×•×ª. ×”×’×¨×£ ××¦×™×’ ××ª ×”×©×™×¤×•×¨ ×œ××•×¨×š ×–××Ÿ.</p>
                    </div>
                </div>

                <div class="examples">
                    <div class="example-card">
                        <h4>ğŸ‘ï¸ ×–×™×”×•×™ ×ª××•× ×•×ª</h4>
                        <p>CNN ×œ×–×™×”×•×™ ××•×‘×™×™×§×˜×™× ×‘×ª××•× ×•×ª</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ—£ï¸ ×¢×™×‘×•×“ ×©×¤×”</h4>
                        <p>RNN ×•-Transformer ×œ×ª×¨×’×•× ×•× ×™×ª×•×— ×˜×§×¡×˜</p>
                    </div>
                    <div class="example-card">
                        <h4>ğŸ¨ ×™×¦×™×¨×ª ×ª×•×›×Ÿ</h4>
                        <p>GAN ×œ×™×¦×™×¨×ª ×ª××•× ×•×ª ×•××•×× ×•×ª</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        // ========== SUPERVISED LEARNING ==========
        
        // Classification
        let classificationCtx = document.getElementById('classificationCanvas').getContext('2d');
        let classificationData = { class1: [], class2: [] };
        let decisionBoundary = null;

        document.getElementById('classificationCanvas').addEventListener('click', (e) => {
            const rect = classificationCtx.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const normalizedX = (x / 600) * 2 - 1;
            const normalizedY = 1 - (y / 400) * 2;
            
            if (x < 300) {
                classificationData.class1.push({x: normalizedX, y: normalizedY});
            } else {
                classificationData.class2.push({x: normalizedX, y: normalizedY});
            }
            drawClassification();
        });

        function drawClassification() {
            classificationCtx.clearRect(0, 0, 600, 400);
            
            // Draw decision boundary
            if (decisionBoundary) {
                classificationCtx.strokeStyle = '#4CAF50';
                classificationCtx.lineWidth = 3;
                classificationCtx.beginPath();
                for (let x = 0; x < 600; x++) {
                    const normalizedX = (x / 600) * 2 - 1;
                    const y = decisionBoundary(normalizedX);
                    const pixelY = (1 - y) / 2 * 400;
                    if (x === 0) classificationCtx.moveTo(x, pixelY);
                    else classificationCtx.lineTo(x, pixelY);
                }
                classificationCtx.stroke();
            }
            
            // Draw class 1 points
            classificationData.class1.forEach(point => {
                const pixelX = (point.x + 1) / 2 * 600;
                const pixelY = (1 - point.y) / 2 * 400;
                classificationCtx.fillStyle = '#ff6384';
                classificationCtx.beginPath();
                classificationCtx.arc(pixelX, pixelY, 8, 0, Math.PI * 2);
                classificationCtx.fill();
            });
            
            // Draw class 2 points
            classificationData.class2.forEach(point => {
                const pixelX = (point.x + 1) / 2 * 600;
                const pixelY = (1 - point.y) / 2 * 400;
                classificationCtx.fillStyle = '#36a2eb';
                classificationCtx.beginPath();
                classificationCtx.arc(pixelX, pixelY, 8, 0, Math.PI * 2);
                classificationCtx.fill();
            });
        }

        function trainClassifier() {
            if (classificationData.class1.length === 0 && classificationData.class2.length === 0) {
                alert('×× × ×”×•×¡×£ × ×§×•×“×•×ª ×ª×—×™×œ×”');
                return;
            }
            
            // Simple linear classifier
            const allPoints = [
                ...classificationData.class1.map(p => ({...p, label: -1})),
                ...classificationData.class2.map(p => ({...p, label: 1}))
            ];
            
            // Perceptron algorithm
            let w0 = 0, w1 = 0, w2 = 0;
            for (let epoch = 0; epoch < 100; epoch++) {
                allPoints.forEach(point => {
                    const prediction = w0 + w1 * point.x + w2 * point.y;
                    if (prediction * point.label <= 0) {
                        w0 += 0.1 * point.label;
                        w1 += 0.1 * point.label * point.x;
                        w2 += 0.1 * point.label * point.y;
                    }
                });
            }
            
            decisionBoundary = (x) => {
                return -(w0 + w1 * x) / w2;
            };
            
            drawClassification();
        }

        function clearClassificationCanvas() {
            classificationData = { class1: [], class2: [] };
            decisionBoundary = null;
            drawClassification();
        }

        function addRandomPoints() {
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 0.6 - 0.3;
                const y = Math.random() * 0.6 - 0.3;
                classificationData.class1.push({x, y});
            }
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 0.6 + 0.3;
                const y = Math.random() * 0.6 - 0.3;
                classificationData.class2.push({x, y});
            }
            drawClassification();
        }

        // Regression
        let regressionChart = null;
        let regressionData = [];
        
        function initRegression() {
            const ctx = document.getElementById('regressionChart').getContext('2d');
            regressionData = [];
            for (let i = 0; i < 20; i++) {
                const x = i / 19;
                const y = Math.sin(x * Math.PI * 2) * 0.3 + 0.5 + (Math.random() - 0.5) * 0.2;
                regressionData.push({x, y});
            }
            
            if (regressionChart) regressionChart.destroy();
            regressionChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '× ×ª×•× ×™×',
                        data: regressionData.map(p => ({x: p.x * 100, y: p.y * 100})),
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        pointRadius: 6
                    }, {
                        label: '×¨×’×¨×¡×™×”',
                        data: [],
                        type: 'line',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'X' } },
                        y: { title: { display: true, text: 'Y' }, min: 0, max: 100 }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' }
                    }
                }
            });
            updateRegression();
        }

        function updateRegression() {
            const degree = parseInt(document.getElementById('polynomialDegree').value);
            document.getElementById('degreeValue').textContent = degree;
            
            if (!regressionChart) return;
            
            // Polynomial regression
            const n = regressionData.length;
            const X = regressionData.map(p => {
                const row = [1];
                for (let d = 1; d <= degree; d++) {
                    row.push(Math.pow(p.x, d));
                }
                return row;
            });
            
            const y = regressionData.map(p => p.y);
            
            // Simple least squares
            const XT = X[0].map((_, i) => X.map(row => row[i]));
            const XTX = XT.map(row => X[0].map((_, i) => row.reduce((sum, val, j) => sum + val * XT[i][j], 0)));
            const XTy = XT.map(row => row.reduce((sum, val, i) => sum + val * y[i], 0));
            
            // Solve (simplified)
            const coeffs = new Array(degree + 1).fill(0);
            for (let i = 0; i <= degree; i++) {
                coeffs[i] = XTy[i] / (XTX[i][i] || 1);
            }
            
            const regressionPoints = [];
            for (let x = 0; x <= 100; x++) {
                const normalizedX = x / 100;
                let y = 0;
                for (let d = 0; d <= degree; d++) {
                    y += coeffs[d] * Math.pow(normalizedX, d);
                }
                regressionPoints.push({x, y: y * 100});
            }
            
            regressionChart.data.datasets[1].data = regressionPoints;
            regressionChart.update();
        }

        function addNoise() {
            regressionData = regressionData.map(p => ({
                x: p.x,
                y: p.y + (Math.random() - 0.5) * 0.1
            }));
            regressionChart.data.datasets[0].data = regressionData.map(p => ({x: p.x * 100, y: p.y * 100}));
            regressionChart.update();
            updateRegression();
        }

        function resetRegression() {
            initRegression();
        }

        // ========== UNSUPERVISED LEARNING ==========
        
        // K-Means Clustering
        let clusteringCtx = document.getElementById('clusteringCanvas').getContext('2d');
        let clusteringPoints = [];
        let centroids = [];
        let clusters = [];
        const colors = ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40'];

        function generateClusters() {
            clusteringPoints = [];
            const k = parseInt(document.getElementById('kValue').value);
            for (let i = 0; i < k; i++) {
                const centerX = Math.random() * 0.6 - 0.3;
                const centerY = Math.random() * 0.6 - 0.3;
                for (let j = 0; j < 15; j++) {
                    clusteringPoints.push({
                        x: centerX + (Math.random() - 0.5) * 0.3,
                        y: centerY + (Math.random() - 0.5) * 0.3
                    });
                }
            }
            drawClustering();
        }

        function drawClustering() {
            clusteringCtx.clearRect(0, 0, 600, 400);
            
            // Draw points
            clusteringPoints.forEach((point, i) => {
                const pixelX = (point.x + 1) / 2 * 600;
                const pixelY = (1 - point.y) / 2 * 400;
                const color = clusters[i] !== undefined ? colors[clusters[i] % colors.length] : '#999';
                clusteringCtx.fillStyle = color;
                clusteringCtx.beginPath();
                clusteringCtx.arc(pixelX, pixelY, 6, 0, Math.PI * 2);
                clusteringCtx.fill();
            });
            
            // Draw centroids
            centroids.forEach((centroid, i) => {
                const pixelX = (centroid.x + 1) / 2 * 600;
                const pixelY = (1 - centroid.y) / 2 * 400;
                clusteringCtx.fillStyle = colors[i % colors.length];
                clusteringCtx.beginPath();
                clusteringCtx.arc(pixelX, pixelY, 12, 0, Math.PI * 2);
                clusteringCtx.fill();
                clusteringCtx.strokeStyle = '#333';
                clusteringCtx.lineWidth = 2;
                clusteringCtx.stroke();
            });
            
            updateLegend();
        }

        function updateLegend() {
            const k = parseInt(document.getElementById('kValue').value);
            const legend = document.getElementById('clusteringLegend');
            legend.innerHTML = '';
            for (let i = 0; i < k; i++) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colors[i]}"></div>
                    <span>××©×›×•×œ ${i + 1}</span>
                `;
                legend.appendChild(item);
            }
        }

        function updateKMeans() {
            const k = parseInt(document.getElementById('kValue').value);
            document.getElementById('kValueDisplay').textContent = k;
            updateLegend();
            if (clusteringPoints.length > 0) {
                runKMeans();
            }
        }

        async function runKMeans() {
            if (clusteringPoints.length === 0) {
                generateClusters();
            }
            
            const k = parseInt(document.getElementById('kValue').value);
            
            // Initialize centroids randomly
            centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: Math.random() * 1.2 - 0.6,
                    y: Math.random() * 1.2 - 0.6
                });
            }
            
            // K-Means algorithm
            for (let iter = 0; iter < 20; iter++) {
                // Assign points to clusters
                clusters = clusteringPoints.map(point => {
                    let minDist = Infinity;
                    let closest = 0;
                    centroids.forEach((centroid, i) => {
                        const dist = Math.pow(point.x - centroid.x, 2) + Math.pow(point.y - centroid.y, 2);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = i;
                        }
                    });
                    return closest;
                });
                
                // Update centroids
                for (let i = 0; i < k; i++) {
                    const clusterPoints = clusteringPoints.filter((_, idx) => clusters[idx] === i);
                    if (clusterPoints.length > 0) {
                        centroids[i] = {
                            x: clusterPoints.reduce((sum, p) => sum + p.x, 0) / clusterPoints.length,
                            y: clusterPoints.reduce((sum, p) => sum + p.y, 0) / clusterPoints.length
                        };
                    }
                }
                
                drawClustering();
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }

        function clearClusteringCanvas() {
            clusteringPoints = [];
            centroids = [];
            clusters = [];
            drawClustering();
        }

        // PCA
        let pcaChart = null;
        let pca3DData = [];
        
        function generatePCA() {
            pca3DData = [];
            for (let i = 0; i < 50; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.5 + 0.5;
                pca3DData.push({
                    x: r * Math.cos(t),
                    y: r * Math.sin(t),
                    z: (Math.random() - 0.5) * 0.3
                });
            }
            drawPCA();
        }

        function drawPCA() {
            const ctx = document.getElementById('pcaChart').getContext('2d');
            if (pcaChart) pcaChart.destroy();
            
            const projected2D = pca3DData.map(p => ({
                x: p.x * 100 + 50,
                y: p.y * 100 + 50
            }));
            
            pcaChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '× ×ª×•× ×™× 2D (××•×§×¨×Ÿ)',
                        data: projected2D,
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'PC1' }, min: 0, max: 100 },
                        y: { title: { display: true, text: 'PC2' }, min: 0, max: 100 }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' }
                    }
                }
            });
        }

        function applyPCA() {
            if (pca3DData.length === 0) {
                generatePCA();
                return;
            }
            // Simple PCA projection (keeping first 2 principal components)
            drawPCA();
        }

        function resetPCA() {
            pca3DData = [];
            if (pcaChart) {
                pcaChart.destroy();
                pcaChart = null;
            }
        }

        // ========== REINFORCEMENT LEARNING ==========
        
        let mazeCtx = document.getElementById('mazeCanvas').getContext('2d');
        const mazeSize = 10;
        let maze = [];
        let agentPos = {x: 0, y: 0};
        let goalPos = {x: 9, y: 9};
        let qTable = {};
        let trainingData = [];
        let isTraining = false;

        function initMaze() {
            maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(0));
            maze[goalPos.y][goalPos.x] = 2; // Goal
            agentPos = {x: 0, y: 0};
            qTable = {};
            trainingData = [];
            drawMaze();
        }

        function drawMaze() {
            const cellSize = 500 / mazeSize;
            mazeCtx.clearRect(0, 0, 500, 500);
            
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    const pixelX = x * cellSize;
                    const pixelY = y * cellSize;
                    
                    if (maze[y][x] === 2) {
                        mazeCtx.fillStyle = '#4CAF50';
                        mazeCtx.fillRect(pixelX, pixelY, cellSize, cellSize);
                    } else {
                        mazeCtx.fillStyle = '#f0f0f0';
                        mazeCtx.fillRect(pixelX, pixelY, cellSize, cellSize);
                    }
                    
                    mazeCtx.strokeStyle = '#ddd';
                    mazeCtx.strokeRect(pixelX, pixelY, cellSize, cellSize);
                }
            }
            
            // Draw agent
            const agentX = agentPos.x * cellSize + cellSize / 2;
            const agentY = agentPos.y * cellSize + cellSize / 2;
            mazeCtx.fillStyle = '#ff6384';
            mazeCtx.beginPath();
            mazeCtx.arc(agentX, agentY, cellSize / 3, 0, Math.PI * 2);
            mazeCtx.fill();
        }

        function getState() {
            return `${agentPos.x},${agentPos.y}`;
        }

        function getQValue(state, action) {
            const key = `${state}-${action}`;
            return qTable[key] || 0;
        }

        function setQValue(state, action, value) {
            const key = `${state}-${action}`;
            qTable[key] = value;
        }

        function getPossibleActions() {
            const actions = [];
            if (agentPos.x > 0) actions.push('left');
            if (agentPos.x < mazeSize - 1) actions.push('right');
            if (agentPos.y > 0) actions.push('up');
            if (agentPos.y < mazeSize - 1) actions.push('down');
            return actions;
        }

        function takeAction(action) {
            const oldPos = {...agentPos};
            switch(action) {
                case 'left': agentPos.x--; break;
                case 'right': agentPos.x++; break;
                case 'up': agentPos.y--; break;
                case 'down': agentPos.y++; break;
            }
            return oldPos;
        }

        async function trainAgent() {
            if (isTraining) return;
            isTraining = true;
            const episodes = parseInt(document.getElementById('trainingEpisodes').value);
            const alpha = 0.1;
            const gamma = 0.9;
            const epsilon = 0.3;
            
            trainingData = [];
            
            for (let episode = 0; episode < episodes; episode++) {
                agentPos = {x: 0, y: 0};
                let steps = 0;
                let totalReward = 0;
                
                while (steps < 100) {
                    const state = getState();
                    const actions = getPossibleActions();
                    let action;
                    
                    if (Math.random() < epsilon) {
                        action = actions[Math.floor(Math.random() * actions.length)];
                    } else {
                        action = actions.reduce((best, a) => 
                            getQValue(state, a) > getQValue(state, best) ? a : best
                        );
                    }
                    
                    const oldPos = takeAction(action);
                    const reward = (agentPos.x === goalPos.x && agentPos.y === goalPos.y) ? 100 : -1;
                    totalReward += reward;
                    
                    const newState = getState();
                    const newActions = getPossibleActions();
                    const maxQ = newActions.length > 0 ? 
                        Math.max(...newActions.map(a => getQValue(newState, a))) : 0;
                    
                    const oldQ = getQValue(state, action);
                    const newQ = oldQ + alpha * (reward + gamma * maxQ - oldQ);
                    setQValue(state, action, newQ);
                    
                    if (reward > 0) break;
                    steps++;
                }
                
                trainingData.push({episode, steps, reward: totalReward});
                
                if (episode % 50 === 0) {
                    updateRLChart();
                    drawMaze();
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            isTraining = false;
            updateRLChart();
            drawMaze();
        }

        async function testAgent() {
            agentPos = {x: 0, y: 0};
            drawMaze();
            
            for (let i = 0; i < 50; i++) {
                const state = getState();
                const actions = getPossibleActions();
                if (actions.length === 0) break;
                
                const action = actions.reduce((best, a) => 
                    getQValue(state, a) > getQValue(state, best) ? a : best
                );
                
                takeAction(action);
                drawMaze();
                await new Promise(resolve => setTimeout(resolve, 200));
                
                if (agentPos.x === goalPos.x && agentPos.y === goalPos.y) break;
            }
        }

        function resetMaze() {
            initMaze();
            if (rlChart) {
                rlChart.destroy();
                rlChart = null;
            }
        }

        function updateEpisodes() {
            document.getElementById('episodesValue').textContent = document.getElementById('trainingEpisodes').value;
        }

        let rlChart = null;
        function updateRLChart() {
            const ctx = document.getElementById('rlChart').getContext('2d');
            if (rlChart) rlChart.destroy();
            
            rlChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: trainingData.map(d => d.episode),
                    datasets: [{
                        label: '××¡×¤×¨ ×¦×¢×“×™×',
                        data: trainingData.map(d => d.steps),
                        borderColor: 'rgba(102, 126, 234, 1)',
                        backgroundColor: 'rgba(102, 126, 234, 0.2)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: '××¤×™×–×•×“×”' } },
                        y: { title: { display: true, text: '×¦×¢×“×™×' }, beginAtZero: true }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' }
                    }
                }
            });
        }

        // ========== DEEP LEARNING ==========
        
        let nnCtx = document.getElementById('neuralNetworkCanvas').getContext('2d');
        let hiddenLayersCount = 2;
        let neuronsPerLayer = 4;
        let isAnimating = false;

        function drawNeuralNetwork() {
            nnCtx.clearRect(0, 0, 800, 500);
            
            const inputSize = 3;
            const outputSize = 2;
            const layerSpacing = 150;
            const startX = 100;
            const neuronRadius = 20;
            const verticalSpacing = 60;
            
            const layers = [
                {size: inputSize, x: startX, label: '×§×œ×˜'},
                ...Array(hiddenLayersCount).fill().map((_, i) => ({
                    size: neuronsPerLayer,
                    x: startX + layerSpacing * (i + 1),
                    label: `× ×¡×ª×¨×ª ${i + 1}`
                })),
                {size: outputSize, x: startX + layerSpacing * (hiddenLayersCount + 1), label: '×¤×œ×˜'}
            ];
            
            // Draw connections
            for (let l = 0; l < layers.length - 1; l++) {
                const layer1 = layers[l];
                const layer2 = layers[l + 1];
                
                for (let i = 0; i < layer1.size; i++) {
                    const y1 = 100 + i * verticalSpacing + (500 - 100 - (layer1.size - 1) * verticalSpacing) / 2;
                    for (let j = 0; j < layer2.size; j++) {
                        const y2 = 100 + j * verticalSpacing + (500 - 100 - (layer2.size - 1) * verticalSpacing) / 2;
                        nnCtx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                        nnCtx.lineWidth = 1;
                        nnCtx.beginPath();
                        nnCtx.moveTo(layer1.x, y1);
                        nnCtx.lineTo(layer2.x, y2);
                        nnCtx.stroke();
                    }
                }
            }
            
            // Draw neurons
            layers.forEach((layer, layerIdx) => {
                for (let i = 0; i < layer.size; i++) {
                    const y = 100 + i * verticalSpacing + (500 - 100 - (layer.size - 1) * verticalSpacing) / 2;
                    
                    nnCtx.fillStyle = '#667eea';
                    nnCtx.beginPath();
                    nnCtx.arc(layer.x, y, neuronRadius, 0, Math.PI * 2);
                    nnCtx.fill();
                    nnCtx.strokeStyle = '#333';
                    nnCtx.lineWidth = 2;
                    nnCtx.stroke();
                }
                
                // Draw label
                nnCtx.fillStyle = '#333';
                nnCtx.font = '14px Arial';
                nnCtx.textAlign = 'center';
                nnCtx.fillText(layer.label, layer.x, 50);
            });
        }

        function updateNeuralNetwork() {
            hiddenLayersCount = parseInt(document.getElementById('hiddenLayers').value);
            neuronsPerLayer = parseInt(document.getElementById('neuronsPerLayer').value);
            document.getElementById('layersValue').textContent = hiddenLayersCount;
            document.getElementById('neuronsValue').textContent = neuronsPerLayer;
            drawNeuralNetwork();
        }

        async function animateForward() {
            if (isAnimating) return;
            isAnimating = true;
            
            // Simple animation - highlight neurons in sequence
            const layers = [
                3,
                ...Array(hiddenLayersCount).fill(neuronsPerLayer),
                2
            ];
            
            for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                drawNeuralNetwork();
                const layerSize = layers[layerIdx];
                const layerSpacing = 150;
                const startX = 100;
                const verticalSpacing = 60;
                const x = startX + layerSpacing * layerIdx;
                
                for (let i = 0; i < layerSize; i++) {
                    const y = 100 + i * verticalSpacing + (500 - 100 - (layerSize - 1) * verticalSpacing) / 2;
                    nnCtx.fillStyle = '#ff6384';
                    nnCtx.beginPath();
                    nnCtx.arc(x, y, 25, 0, Math.PI * 2);
                    nnCtx.fill();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            drawNeuralNetwork();
            isAnimating = false;
        }

        function resetNeuralNetwork() {
            drawNeuralNetwork();
        }

        // Training Chart
        let trainingChart = null;
        let trainingInterval = null;
        let trainingLoss = [];
        let trainingEpoch = 0;

        function startTraining() {
            if (trainingInterval) return;
            
            trainingLoss = [];
            trainingEpoch = 0;
            
            trainingInterval = setInterval(() => {
                trainingEpoch++;
                const loss = Math.max(0.1, 10 * Math.exp(-trainingEpoch / 50) + Math.random() * 0.5);
                trainingLoss.push({epoch: trainingEpoch, loss});
                
                if (trainingLoss.length > 100) {
                    trainingLoss.shift();
                }
                
                updateTrainingChart();
            }, 100);
        }

        function stopTraining() {
            if (trainingInterval) {
                clearInterval(trainingInterval);
                trainingInterval = null;
            }
        }

        function resetTraining() {
            stopTraining();
            trainingLoss = [];
            trainingEpoch = 0;
            updateTrainingChart();
        }

        function updateTrainingChart() {
            const ctx = document.getElementById('trainingChart').getContext('2d');
            if (trainingChart) trainingChart.destroy();
            
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: trainingLoss.map(d => d.epoch),
                    datasets: [{
                        label: 'Loss',
                        data: trainingLoss.map(d => d.loss),
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: '××¤×•×š (Epoch)' } },
                        y: { title: { display: true, text: 'Loss' }, beginAtZero: true }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' }
                    }
                }
            });
        }

        // Initialize
        window.addEventListener('load', () => {
            initRegression();
            initMaze();
            drawNeuralNetwork();
            updateTrainingChart();
        });
    </script>
</body>
</html>
